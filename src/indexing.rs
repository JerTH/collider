//! Indexing
//! 
//! This module is for creating and using indexes attached to an [EntityDatabase]
//! 
//! Indexes (Indices) are used to speed up access into the [EntityDatabase] for more
//! specialized queries
use std::{fmt::Debug, marker::PhantomData};
use crate::{Component, EntityId, components::ComponentType, database::reckoning::AnyPtr, EntityDatabase, transform::{Rows, TransformationResult}, column::ColumnKey};

/// A [DatabaseIndex] describes an index of data stored adjacent to an [EntityDatabase] which
/// organizes its own list of [EntityId]'s it's interest in based on some [Component].
/// 
/// When a [DatabaseIndex] is added to an [EntityDatabase] a hook is created to allow the index
/// to respond to changes to the [Component] type which the [IndexQuery] is interested in.
/// These changes are used by the [DatabaseIndex] to organize, relate, associate, or otherwise
/// keep track of, interesting relationships between entities.
/// 
/// [DatabaseIndex]'s can be queried using an [IndexQuery]. When an [IndexQuery] is executed
/// it is allowed to use whatever data is stored in its associated [DatabaseIndex] to build a
/// list of entities which match whatever predicate the query is meant to satisfy.
/// This list of entities is then used to accelerate a [Transformation] being executed
/// on the [EntityDatabase]
pub trait DatabaseIndex<C: Component>: Default {
    /// Returns an iterator over every [EntityId] currently indexed
    fn indexed<'i>(&'i self) -> impl Iterator<Item = EntityId> + 'i;

    /// Called whenever a component we're interested in changes
    fn on_change<'i>(&'i self, entity: &EntityId, new_value: &C);

    /// Runs an [IndexQuery] on a [DatabaseIndex], returning an iterator over its results
    fn query<'i, Q: IndexQuery<C> + 'i>(index: &'i Q::Index, query: Q) -> impl Iterator<Item = EntityId> + 'i
    where
        <Q as IndexQuery<C>>::Index: DatabaseIndex<C>,
    {
        Q::on_index(query, &index)
    }
}

/// An [IndexQuery] represents a question to be asked of a [DatabaseIndex] attached
/// to an [EntityDatabase]
pub trait IndexQuery<C: Component> {
    type Index;
    type Component;

    fn on_index<'i>(query: Self, index: &'i Self::Index) -> impl Iterator<Item = EntityId> + 'i
    where
        Self::Index: DatabaseIndex<C>;
}

struct RealQuery<'db, I: DatabaseIndex<C>, C:Component> {
    index: &'db I,
    _phantom: PhantomData<C>,
}

/// A [QueryIter] is in iterator over a filtered set of entities in an [EntityDatabase]
/// generated by an [IndexQuery] run on a [DatabaseIndex]
struct QueryIter<'db, QTuple> {
    db: &'db EntityDatabase,

    marker: PhantomData<QTuple>,

    /// The list of entities gathered by our query
    entities: Vec<EntityId>,
}

impl<'db, C: Component> Iterator for QueryIter<'db, C> {
    type Item = &'db C;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

impl<'db, C: Component, I: DatabaseIndex<C>> IntoIterator for RealQuery<'db, I, C>
{
    type Item = &'db C;
    type IntoIter = QueryIter<'db, C>;

    fn into_iter(self) -> Self::IntoIter {
        todo!()
    }
}

pub trait Index<I> {}

/// Type erased database index
/// 
/// Encapsulates a real [DatabaseIndex]
#[derive(Debug)]
pub struct DatabaseIndexType {
    associated_type: ComponentType,
    fn_refresh: fn(),
    ptr_index: AnyPtr,
}

impl DatabaseIndexType {
    pub fn default_from_type<I: DatabaseIndex<C> + 'static, C: Component>() -> Self {
        todo!()
    }
}

/// [IndexingTransformation]'s are a special form of [Transformation] that are
/// specifically for reading an [EntityDatabase]'s state and updating a [DatabaseIndex]
/// 
/// This works similarly to a normal [Transformation] in that the [DatabaseIndex] can be
/// updated with data from multiple components brought in via the [Self::Data] item
pub trait IndexingTransformation {
    type Data;
    type Index;

    fn run(
        data: IndexingRows<Self::Data>,
        index: &mut Self::Index
    ) -> TransformationResult;
}


pub struct IndexingRows<'db, RTuple> {
    /// A reference into the [EntityDatabase] we're iterating
    pub(crate) db: &'db EntityDatabase,

    /// Keys to columns which have been marked as dirty
    pub(crate) keys: Vec<ColumnKey>,

    /// The width of the row
    pub(crate) width: usize,

    pub(crate) marker: PhantomData<RTuple>,
}

impl<'db, ITuple> IndexingRows<'db, ITuple> {
    pub fn database(&self) -> &'db EntityDatabase {
        self.db
    }
    
    pub fn keys(&self) -> &Vec<ColumnKey> {
        &self.keys
    }

    pub fn width(&self) -> usize {
        self.width
    }
}


pub struct IndexingRowIter<'db, ITuple> {
    // allow statement fixes never read lint - this is in fact read but only within a macro
    #[allow(dead_code)] pub(crate) db: &'db EntityDatabase,

    marker: PhantomData<ITuple>,
}

impl<'db, ITuple> IndexingRowIter<'db, ITuple> {
    pub fn new(db: &'db EntityDatabase) -> Self {
        Self {
            db,
            marker: Default::default(),
        }
    }
}
