//! Indexing
//! 
//! This module is for creating and using indexes attached to an [EntityDatabase]
//! 
//! Indexes (Indices) are used to speed up access into the [EntityDatabase] for more
//! specialized queries
use std::{fmt::Debug, marker::PhantomData};
use crate::{Component, EntityId, components::ComponentType, database::reckoning::AnyPtr, EntityDatabase, transform::{Rows, TransformationResult, Selection, ReadWrite}, column::ColumnKey, Read};

/// A [DatabaseIndex] describes an index of data stored adjacent to an [EntityDatabase] which
/// organizes its own list of [EntityId]'s it's interested in based on some [Component] data.
/// 
/// When a [DatabaseIndex] is added to an [EntityDatabase] a hook is created to allow the index
/// to respond to changes to the [Component] type which the [IndexQuery] is interested in.
/// These changes are used by the [DatabaseIndex] to organize, relate, associate, or otherwise
/// keep track of interesting information about entities.
/// 
/// [DatabaseIndex]'s can be queried using an [IndexQuery]. When an [IndexQuery] is executed
/// it is allowed to use whatever data is stored in its associated [DatabaseIndex] to build a
/// list of entities which match whatever predicate the query is meant to satisfy.
/// This list of entities is then used to accelerate a [Transformation] being executed
/// on the [EntityDatabase]
pub trait DatabaseIndex: Default {

    /// An [IndexingTransformation] is a special transformation
    /// run on an [EntityDatabase] specifically for updating
    /// a [DatabaseIndex]. It's purpose is to iterate through
    /// all of the components it's interested in, extract some
    /// useful property or information about them, and then index
    /// that information in the [DatabaseIndex] to be looked up
    /// by an [IndexQuery] later
    type IndexingTransformation: IndexingTransformation;

    type Data: Selection;

    /// Returns an iterator over every [EntityId] currently tracked
    /// by the [EntityDatabase]
    fn indexed<'i>(&'i self) -> impl Iterator<Item = EntityId> + 'i;

    ///// Runs an [IndexQuery] on a [DatabaseIndex], returning an iterator over its results
    //fn query<'i, Q: IndexQuery<C> + 'i>(index: &'i Q::Index, query: Q) -> impl Iterator<Item = EntityId> + 'i
    //where
    //    <Q as IndexQuery<C>>::Index: DatabaseIndex<C>,
    //{
    //    Q::on_index(query, &index)
    //}
}

/// An [IndexQuery] represents a question to be asked of a [DatabaseIndex] attached
/// to an [EntityDatabase]
pub trait IndexQuery {
    type Index;
    type Data;

    fn on_index<'i>(query: Self, index: &'i Self::Index) -> impl Iterator<Item = EntityId> + 'i
    where
        Self::Index: DatabaseIndex;
}

impl<Q, I: DatabaseIndex> Component for Q
where
    Q: Debug + Default + Clone + 'static,
    Q: IndexQuery<Index = I, Data = <I as DatabaseIndex>::Data>,
    <I as DatabaseIndex>::Data: Selection,
    <I as DatabaseIndex>::IndexingTransformation: IndexingTransformation,
{
    fn is_query_component() -> bool { true }
}

struct RealQuery<'db, I: DatabaseIndex, C: Component> {
    index: &'db I,
    _phantom: PhantomData<C>,
}

/// A [QueryIter] is in iterator over a filtered set of entities in an [EntityDatabase]
/// generated by an [IndexQuery] run on a [DatabaseIndex]
struct QueryIter<'db, QTuple> {
    /// The [EntityDatabase] we're running a query on
    db: &'db EntityDatabase,

    marker: PhantomData<QTuple>,

    /// The list of entities gathered by our query
    entities: Vec<EntityId>,

    /// The list of keys to columns the iterator is
    /// interested in accessing
    keys: Vec<ColumnKey>,
}

impl<'db, C: Component> Iterator for QueryIter<'db, C> {
    type Item = &'db C;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

impl<'db, C: Component, I: DatabaseIndex> IntoIterator for RealQuery<'db, I, C>
{
    type Item = &'db C;
    type IntoIter = QueryIter<'db, C>;

    fn into_iter(self) -> Self::IntoIter {
        todo!()
    }
}

pub trait Index<I> {}

/// Type erased database index
/// 
/// Encapsulates a real [DatabaseIndex]
#[derive(Debug)]
pub struct DatabaseIndexType {
    ptr_index: AnyPtr,
}

impl DatabaseIndexType {
    pub fn from_index<I: DatabaseIndex + 'static>(index: I) -> Self {
        Self {
            ptr_index: AnyPtr::from(Box::new(index)),
        }
    }
}

/// [IndexingTransformation]'s are a special form of [Transformation] that are
/// specifically for reading an [EntityDatabase]'s state and updating a [DatabaseIndex]
/// 
/// This works similarly to a normal [Transformation] in that the [DatabaseIndex] can be
/// updated with data from multiple components brought in via the [Self::Data] item
pub trait IndexingTransformation {
    type Data;
    type Index;

    fn run(
        data: IndexingRows<Self::Data>,
        index: &mut Self::Index
    ) -> TransformationResult;

    fn new() -> Self where Self: Sized + Default {
        Self::default()
    }
}


pub struct IndexingRows<'db, RTuple> {
    /// A reference into the [EntityDatabase] we're iterating
    pub(crate) db: &'db EntityDatabase,

    /// Keys to columns which have been marked as dirty
    pub(crate) keys: Vec<ColumnKey>,

    /// The width of the row
    pub(crate) width: usize,

    pub(crate) marker: PhantomData<RTuple>,
}

impl<'db, ITuple> IndexingRows<'db, ITuple> {
    pub fn database(&self) -> &'db EntityDatabase {
        self.db
    }
    
    pub fn keys(&self) -> &Vec<ColumnKey> {
        &self.keys
    }

    pub fn width(&self) -> usize {
        self.width
    }
}

pub struct IndexingRowIter<'db, ITuple> {
    // allow statement fixes never read lint - this is in fact read but only within a macro
    #[allow(dead_code)] pub(crate) db: &'db EntityDatabase,

    marker: PhantomData<ITuple>,
}

impl<'db, ITuple> IndexingRowIter<'db, ITuple> {
    pub fn new(db: &'db EntityDatabase) -> Self {
        Self {
            db,
            marker: Default::default(),
        }
    }
}
