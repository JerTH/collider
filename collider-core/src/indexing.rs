//! Indexing
//! 
//! This module is for creating and using indexes attached to an [EntityDatabase]
//! 
//! Indexes (Indices) are used to speed up access into the [EntityDatabase] for more
//! specialized queries
use std::{fmt::Debug, marker::PhantomData};
use crate::{EntityDatabase, Component, EntityId, any::AnyPtr, id::ColumnKey, results::TransformationResult, component::ComponentType, DatabaseSelection, select::Selects };

/// A [DatabaseIndex] describes an index of data stored adjacent to an [EntityDatabase] which
/// organizes its own list of [EntityId]'s it's interested in based on some [Component] data.
/// 
/// When a [DatabaseIndex] is added to an [EntityDatabase] a hook is created to allow the index
/// to respond to changes to the [Component] type which the [IndexQuery] is interested in.
/// These changes are used by the [DatabaseIndex] to organize, relate, associate, or otherwise
/// keep track of interesting information about entities.
/// 
/// [DatabaseIndex]'s can be queried using an [IndexQuery]. When an [IndexQuery] is executed
/// it is allowed to use whatever data is stored in its associated [DatabaseIndex] to build a
/// list of entities which match whatever predicate the query is meant to satisfy.
/// This list of entities is then used to accelerate a [Transformation] being executed
/// on the [EntityDatabase]
pub trait DatabaseIndex: Default {

    /// An [IndexingTransformation] is a special transformation
    /// run on an [EntityDatabase] specifically for updating
    /// a [DatabaseIndex]. It's purpose is to iterate through
    /// all of the components it's interested in, extract some
    /// useful property or information about them, and then index
    /// that information in the [DatabaseIndex] to be looked up
    /// by an [IndexQuery] later
    type IndexingTransformation: IndexingTransformation;

    type Data;
    
    /// Returns an iterator over every [EntityId] currently tracked
    /// by the [EntityDatabase]
    fn indexed<'i>(&'i self) -> impl Iterator<Item = EntityId> + 'i;

    ///// Runs an [IndexQuery] on a [DatabaseIndex], returning an iterator over its results
    //fn query<'i, Q: IndexQuery<C> + 'i>(index: &'i Q::Index, query: Q) -> impl Iterator<Item = EntityId> + 'i
    //where
    //    <Q as IndexQuery<C>>::Index: DatabaseIndex<C>,
    //{
    //    Q::on_index(query, &index)
    //}
}

/// An [IndexQuery] represents a question to be asked of a [DatabaseIndex] attached
/// to an [EntityDatabase]
pub trait IndexQuery {
    type Index;
    type Selects: IndexQuerySelection;

    fn find_matches<'i>(query: Self, index: &'i Self::Index) -> impl Iterator<Item = EntityId> + 'i
    where
        Self::Index: DatabaseIndex;
}

/// The component selection for an IndexQuery
/// 
/// Indicates which components a query may iterate
pub trait IndexQuerySelection: Selects {}

//impl<T> IndexQuerySelection for T
//where
//    T: IndexQuery,
//    <T as IndexQuery>::Row: DatabaseSelection
//{
//    fn reads() -> &'static [ComponentType] {
//        <T as IndexQuery>::Row::READS
//    }
//
//    fn writes() -> &'static [ComponentType] {
//        <T as IndexQuery>::Row::WRITES
//    }
//}

impl<T> IndexQuerySelection for T
where
    T: Selects,
{}

struct RealQuery<'db, I: DatabaseIndex, C: Component, D: EntityDatabase> {
    _database: &'db D,
    _index: &'db I,
    _phantom: PhantomData<C>,
}

/// A [QueryIter] is in iterator over a filtered set of entities in an [EntityDatabase]
/// generated by an [IndexQuery] run on a [DatabaseIndex]
struct QueryIter<'db, QTuple, D: EntityDatabase> {
    /// The [EntityDatabase] we're running a query on
    _db: &'db D,
    
    marker: PhantomData<QTuple>,

    /// The list of entities gathered by our query
    _entities: Vec<EntityId>,

    /// The list of keys to columns the iterator is
    /// interested in accessing
    _keys: Vec<ColumnKey>,
}

impl<'db, C: Component, D: EntityDatabase> Iterator for QueryIter<'db, C, D> {
    type Item = &'db C;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

impl<'db, C: Component, I: DatabaseIndex, D: EntityDatabase + 'db> IntoIterator for RealQuery<'db, I, C, D>
{
    type Item = &'db C;
    type IntoIter = QueryIter<'db, C, D>;

    fn into_iter(self) -> Self::IntoIter {
        todo!()
    }
}

pub trait Index<I> {}

/// Type erased database index
/// 
/// Encapsulates a real [DatabaseIndex]
#[derive(Debug)]
pub struct DatabaseIndexType {
    _ptr_index: AnyPtr,
}

impl DatabaseIndexType {
    pub fn from_index<I: DatabaseIndex + 'static>(index: I) -> Self {
        Self {
            _ptr_index: AnyPtr::from(Box::new(index)),
        }
    }
}

/// [IndexingTransformation]'s are a special form of [Transformation] that are
/// specifically for reading an [EntityDatabase]'s state and updating a [DatabaseIndex]
/// 
/// This works similarly to a normal [Transformation] in that the [DatabaseIndex] can be
/// updated with data from multiple components brought in via the [Self::Data] item
pub trait IndexingTransformation {
    type Data;
    type Index;

    fn run<D: EntityDatabase>(
        data: IndexingRows<Self::Data, D>,
        index: &mut Self::Index
    ) -> TransformationResult;

    fn new() -> Self where Self: Sized + Default {
        Self::default()
    }
}


pub struct IndexingRows<'db, RTuple, D: EntityDatabase> {
    /// A reference into the [EntityDatabase] we're iterating
    pub(crate) db: &'db D,

    /// Keys to columns which have been marked as dirty
    pub(crate) keys: Vec<ColumnKey>,

    /// The width of the row
    pub(crate) width: usize,

    pub(crate) marker: PhantomData<RTuple>,
}

impl<'db, ITuple, D: EntityDatabase> IndexingRows<'db, ITuple, D> {
    pub fn database(&self) -> &'db D {
        self.db
    }
    
    pub fn keys(&self) -> &Vec<ColumnKey> {
        &self.keys
    }

    pub fn width(&self) -> usize {
        self.width
    }
}

pub struct IndexingRowIter<'db, ITuple, D: EntityDatabase> {
    // allow statement fixes never read lint - this is in fact read but only within a macro
    #[allow(dead_code)]
    pub(crate) db: &'db D,

    marker: PhantomData<ITuple>,
}

impl<'db, ITuple, D: EntityDatabase> IndexingRowIter<'db, ITuple, D> {
    pub fn new(db: &'db D) -> Self {
        Self {
            db,
            marker: Default::default(),
        }
    }
}
